<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>beka&#39;s blog blog</title><link href="http://beka.github.com/blog/atom.xml" rel="self"/><link href="http://beka.github.com"/><updated>2011-11-10T22:25:11Z</updated><id>http://beka.github.com</id><entry><title>Algorithms and Data Structures - Great Library</title><author><name>beka</name></author><link href="http://beka.github.com/blog/2011/algorithms_and_data_structures.html"/><updated>2011-08-02T14:55:02Z</updated><published>2011-08-02T14:55:02Z</published><id>http://beka.github.com/blog/2011/algorithms_and_data_structures.html</id><content type="html">
       

&lt;p&gt;Great Library of Computer Science books at Dropbox - &lt;a href=&quot;http://dl.dropbox.com/u/10497693/Library/Computer%20Science/index.html&quot;&gt;Computer Science&lt;/a&gt;&lt;br&gt;&lt;br&gt;
You can download it with this &lt;a href=&quot;https://gist.github.com/1119891&quot;&gt;python script&lt;/a&gt;.
&lt;br&gt;&lt;br&gt;
via &lt;a href=&quot;http://xeno-by.livejournal.com/46082.html&quot;&gt;xeno-by&lt;/a&gt;

   </content></entry><entry><title>Garbage Collection — must read</title><author><name>beka</name></author><link href="http://beka.github.com/blog/2011/garbage_collection.html"/><updated>2011-07-23T22:14:20Z</updated><published>2011-07-23T22:14:20Z</published><id>http://beka.github.com/blog/2011/garbage_collection.html</id><content type="html">
       

&lt;p&gt;Paul R. Wilson, &quot;Uniprocessor Garbage Collection Techniques&quot; [&lt;a href=&quot;http://www.cse.nd.edu/~dthain/courses/cse40243/spring2006/gc-survey.pdf&quot;&gt;PDF&lt;/a&gt;]
&lt;br&gt;&lt;br&gt;
Richard Jones, &quot;Garbage Collection: Algorithms for Automatic Dynamic Memory Management&quot; [&lt;a href=&quot;http://www.amazon.com/exec/obidos/ASIN/0471941484/richardjones&quot;&gt;Amazon&lt;/a&gt;]
&lt;br&gt;&lt;br&gt;
David Plainfossé, A Survey of Distributed Garbage Collection Techniques [&lt;a href=&quot;http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.6060&quot;&gt;index&lt;/a&gt;, &lt;a href=&quot;http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=9F6D0C9943FC16027C36AC1BEA2BAAFC?doi=10.1.1.45.6060&amp;rep=rep1&amp;type=pdf&quot;&gt;pdf&lt;/a&gt;]

   </content></entry><entry><title>Guppy: debugging django application memory leak</title><author><name>beka</name></author><link href="http://beka.github.com/blog/2011/debugging_django_app.html"/><updated>2011-07-22T01:18:29Z</updated><published>2011-07-22T01:18:29Z</published><id>http://beka.github.com/blog/2011/debugging_django_app.html</id><content type="html">
       

&lt;p&gt;&lt;a href=&quot;http://guppy-pe.sourceforge.net/&quot;&gt;Guppy&lt;/a&gt; is a perfect tool for django application&#39;s memory sizing, profiling and analysis. And &lt;a href=&quot;http://blog.mfabrik.com/2008/03/07/debugging-django-memory-leak-with-trackrefs-and-guppy/&quot;&gt;&lt;b&gt;this&lt;/b&gt;&lt;/a&gt; is a nice way to debug your wsgi application.
&lt;br&gt;&lt;br&gt;
&lt;img src=&quot;/media/img/guppy.png&quot;&gt;&lt;/p&gt;

   </content></entry><entry><title>Concurrent Haskell</title><author><name>beka</name></author><link href="http://beka.github.com/blog/2011/concurrent_haskell.html"/><updated>2011-07-21T22:07:29Z</updated><published>2011-07-21T22:07:29Z</published><id>http://beka.github.com/blog/2011/concurrent_haskell.html</id><content type="html">
       

&lt;p&gt;Right now, the area Haskell absolutely thrashes everything else is speedy and lightweight concurrency (it even stomps Erlang in the Debian Shootout). So if you can find a project that needs fluid responsiveness, multi-connection or or multi-CPU scaling, Haskell is the ideal&amp;nbsp;tool.&lt;/p&gt;

   </content></entry></feed>